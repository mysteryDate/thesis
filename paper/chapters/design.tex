%!TEX root = ../thesis.tex
\chapter{Design \& Implementation}

	Development of a graphical user interface for libmapper creates a unique challenge. Obviously such an interface is a practical tool, and should function as such, yet it also must work in concert with DMIs which are inherently designed for creative use. For the purposes of this project, the assumed solution to this innate paradox is to provide the user with multiple independent modes of control.  libmapper itself is an extremely flexible API that makes few assumptions as to the network of devices and signals or how they are mapped. It is thus fitting that a GUI for libmapper would be equally as flexible. In lieu of a single perfect solution for network visualization and interactivity, providing users with various independent solutions offered good compromise.

	Work began with the webmapper interface described in section \ref{sub:webmapper}. An MVC structure was built around the code in order to make the program more extensible and to allow for the easy integration of multiple views. Missing features from Maxmapper are incorporated into the main view mode, known as the ``list'' view. That interface has been extended in various ways, taking advantage of the new code base. Two new view modes, the ``grid'' and ``hive'', both designed by Jonathan Wilansky at IDMIL, are integrated into the main GUI. Finally, the code has been compiled together as a standalone application, ready for wide distribution.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Development of a Flexible System} % (fold)
\label{sec:development_of_a_flexible_system}

Prior GUIs for libmapper have been successfully used for some time, but all have failed to become a standard for the same reason: they cannot accommodate all possible use-cases of libmapper. List based views like the Max/MSP GUI and webmapper cannot show hierarchies while the cluster view implemented in vizmapper can be overly cumbersome for interaction with simple networks. Especially with so much work already completed on prior GUIs, it is more suitable to integrate different approaches into a single GUI than to begin work on some new, hopefully superior approach that would likely prove to be flawed like all that came before it. 

Interface integration is accomplished through an extremely simple approach: a drop-down menu on the upper left corner of the interface. Options on this menu represent different visualization modes available to the user. By selecting a new visualization mode the GUI drastically changes it appearance, replacing nearly every visual element in the display.
	%Needs to be adaptable, show any metadata

	\subsection{MVC architecture} % (fold)
	\label{sec:mvc_architecture}

Because a modular design is desired, the Model-View-Controller (MVC) metaphor for structuring software applications \cite{MVC_krasnerpope} is used as a general framework for structuring the application. In fact, the whole scale swapping in and out of independent visual modes is a very straightforward implementation of MVC. Unfortunately, the \url{libmapper} $\rightarrow$ \url{python monitor} $\rightarrow$ \url{browser} implementation complicates things slightly.\footnote{Compare figure \ref{fig:mapper_network} with (TODO).} A few layers of abstraction are added to take into account the monitor, the network itself and control features independent to the view (see section \ref{sec:top_toolbar}), but the general MVC architecture is maintained.

\begin{figure}[!ht]
\centering
	\includegraphics[width=0.9\textwidth]{figures/mapper_network2}
\caption{MVC hierarchy for the GUI and libmapper, blue arrows show propagation of network changes, dashed arrows denote messages requesting a network change.}
\label{fig:mapper_network}
\end{figure}


		\subsubsection{Independent communication}

First and foremost, it is essential that data on the screen should reflect data on the network. This is not entirely straightforward, as asynchronous messages are constantly being sent from the GUI to libmapper and vice versa. In a truly distributed system, data on the libmapper network change continuously as other users add devices and modify mappings. As can be seen in figure \ref{fig:mapper_network}, the actual libmapper network, the displayed data and user interaction are very insulated from one another. For example, a user command to link two devices (in this case \url{source.1} and \url{dest.1}), will send the following message to the python monitors:

\url{ {"cmd":"link","args":["/source.1","/dest.1"]} }

Meaning: a linking command is sent to \url{source.1} and \url{dest.1} (the message itself is a python dictionary). After this, nothing will change in the display, as it has not yet been notified of a new link. The monitor then relays this message to the network, using libmapper specific syntax. If the link is successful, the monitor receives notice, and sends a message to the main JavaScript file (main.js):

\url{("new_link", {"src_name": "/source.1", "dest_name": "/dest.1"}) }

This states that a new link has been formed between the source device \url{source.1} and the destination device \url{dest.1}. Only then does the GUI respond to the change on the network. Signal data itself is not available to the GUI in any way, as libmapper networks are designed to prevent this kind of bandwidth clutter \shortcite{new_libmapper}.

		\subsubsection{The model}

The model consists of an abstract copy of the network, residing on the local machine. Independent views can consult these data, but cannot directly modify it. Messages from the python monitor announce new links, modifications to connections, or any other changes on the network. The model records these changes into four data structures:

\begin{itemize}
 	\item \url{model.devices}: Storage of all present devices and device metadata.
 	\item \url{model.links}: A record of all links presently on the network.
 	\item \url{model.signals}: Monitors signals on the network, but only signals that are currently visible in the GUI. This is done to save bandwidth and processing power. View-controller pairs keep track of which devices are currently being viewed, and can ask for their child signals. 
 	\item \url{model.connections}: All connections and connection metadata between signals currently in the model.
 \end{itemize} 

It is possible that previously viewed signals will persist in the model, but their connections and themselves will not be updated upon change.

		\subsubsection{View-controller pairs}

All interaction handlers\footnote{Response to mouse clicks and certain keypresses.} and visualizations are stored in modular, view-controller pairs, as recommended by \citeN{MVC_krasnerpope}. Each view controller pair corresponds with a single view mode. Pairs can have any combination of UI handlers and visual features, but must have the following four functions that are called by the main file on which the model is stored:

\begin{itemize}
	\item \url{view.initialize()}: Calls upon the view to create its visual elements and add its individual interaction handlers.
	\item \url{view.get_focused_devices()}: Returns whichever devices are currently visible in the view. This is used for populating the signal and connection data structures.
	\item \url{view.cleanup()}: Causes the controller to remove all interaction handlers.
	\item \url{view.update_display()}: Called whenever the model changes. The view is not made explicit aware of \emph{what} has changed, only that a change has occurs. In each view mode, this call causes visual features to be cleared and re-drawn, much like a screen refresh. Though this creates more processor overhead (see section \ref{sec:testing_program_responsiveness}), it allows for much greater flexibility in designing new views, as the model does not need to be aware of any specific information requirements for each view.
\end{itemize}

	% subsection mvc_architecture (end)

	\subsection{Top toolbar} % (fold)
	\label{sec:top_toolbar}

One crucial way the program departs traditional MVC is that the controller is broken up into two distinct parts. An extra ``user-input'' and controller section sits at the top-right corner of figure \ref{fig:mapper_network}, as a child of \url{main.js}.  It also would be possible to think of this as a separate view-controller pair, running constantly and simultaneously with the others, but since it is a part of the main JavaScript file, network visualization is more straightforward when it is thought of as an isolated controller.

It is sensible to include certain tasks and information providing structures across visualization modes. In light of this, a static toolbar is presented at the top of the GUI. This toolbar contains all administrative controls and connection modification fields.

\begin{figure}[!ht]
\centering
	\includegraphics[width=1\textwidth]{figures/top_toolbar}
\caption{The upper toolbar}
\label{fig:toolbar}
\end{figure}

\begin{itemize}
	\item \textbf{Administrative controls}
	\begin{itemize}
		\item\emph{Load/Save buttons}: These elements respond to clicks and save and load mappings, as discussed in section \ref{sec:saving_and_loading}.
		\item\emph{Visual mode selection}: A drop-down menu containing all possible view modes (at the writing of this thesis: List, Grid and Hive), allowing the user to select between them.
		\item\emph{Refresh Button}: When clicked, all data residing on the model is erased and re-gathered. This is useful if the monitor somehow desynchronizes with the network.
	\end{itemize}

	\item \textbf{Connection modification}
	\begin{itemize}
		\item\emph{Connection mode selectors}: If a single connection is selected within the GUI this array of buttons allows the user to choose between the available connection modes.
		\item\emph{Expression editor}: Here the user inputs a custom expression in ``Expr'' mode. In other modes this field displays the connection's expression but is not editable.
		\item\emph{Source range editor}: These two numbers display the maximum and minimum values of the input signal. It is only editable in the ``Line'' connection mode.
		\item\emph{Destination range editor}: Same as above but for destination signals. Due to boundary conditions these fields are useful in all modes.
		\item\emph{Boundary mode selectors}: Two buttons that cycle through five boundary modes for both the maximum and minimum destination value. A graphic exists to represent each mode.
	\end{itemize}
\end{itemize}

All interface features not present in the top toolbar are part of the current visualization mode and are placed into a ``container'' element below, occupying the remainder of the window.

	% subsection top_toolbar (end)

The file and communication structure described in this section allows for quick modification and extension of the interface. Developers can program new visual modes relatively easily, in comparison to prior GUIs. Hopefully this will eventually lead to a GUI with many useful view modes that can accommodate nearly every use-case for libmapper.

% section development_of_a_flexible_system (end)

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Integration of Interface Features} % (fold)
\label{sec:integration_of_interface_features}

Development began by unifying features of the Maxmapper onto the Webmapper code. Webmapper was selected as a starting point because of cross-platform nature of a web-based implementation. The general two-table structure of Maxmapper and Webmapper created the first view mode of the interface, known as the ``list'' view.

	\subsection{Structure of the list view} % (fold)
	\label{sub:the_list_view}

The list view provides the most straightforward way to visualize and interact with libmapper. Two tables dominate the visible area, listing source elements on the left and destination elements on the right. B\'ezier curves form lines between associated list elements on each each list. Because these curves do not always represent the same data structures, the lines themselves are referred to as \emph{arrows} by the GUI code and by this document.

\begin{figure}[ht]
\centering
	\scalebox{0.4}{\includegraphics{figures/list_view_all_devices}}
\caption{The list view with all devices selected}
\label{fig:list_view_all_devices}
\end{figure}

The view itself is divided into two major modes: ``All Devices'' and individual linked source devices. Switching between these modes is accomplished through tabs that appear at the top of the container, much like the tabs in modern web browsers. In the All Devices tab, every device displayed on the network is listed in one of the two columns, as in figure \ref{fig:list_view_all_devices}. Source devices are listed in the left table, while the right table lists destination devices. Intermediate devices, such as implicit mappers described in \cite{interpolated_mappings}, will be listed in both tables. Here arrows represent links between devices. Currently the GUI provides users with names, the number of child signals, IP addresses and a port for every device. Since no connections or signals are displayed, most of the top bar (see section \ref{sec:top_toolbar}) is disabled in the All Devices tab. Saving and loading are also disabled.

\begin{figure}[ht]
\centering
	\includegraphics[width=1\textwidth]{figures/list_view_single_link}
\caption{The list view with device \textbf{testsend.1} selected}
\label{fig:list_view_single_link}
\end{figure}

The GUI draws a tab for every source device with at least one link to a destination device. Clicking on any of these devices will redraw both tables. The left table now shows all child signals for the selected source device while the right table displays child signals for every destination device linked to the selected device. 

	% subsection the_list_view (end)
	
	\subsection{Display libmapper metadata} % (fold)
	\label{sub:display_libmapper_metadata}

The original webmapper interface's tables listing have no headers. Without these queues, only a small amount of metadata is provided (see figure \ref{fig:webmapper}).

\begin{table}
	\centering
	\Tcaption{Metadata available in webmapper vs list view}
	\label{tab:webmapper_list_view_metadata}
		\begin{tabular}{l  l  |  l l }
		\hline\hline
		\textbf{webmapper}&&\textbf{list view}\\
		Devices&Signals&Devices&Signals\\
		\hline
		name&name&name&name\\
		IP address&data type&IP address&data type\\
		port&vector length&port&vector length\\
		&&number of inputs&units\\
		&&number of outputs&maximum value\\
		&&&minimum value\\
		\end{tabular}
\end{table}

To include a useful feature of max mapper, column headers have been added to the list view. Also included are the new pieces of device and signal metadata listed in table \ref{tab:webmapper_list_view_metadata}. Tables draw themselves with invisible extra columns, such that adding extra data can be easily accomplished. If a user embeds extra metadata onto devices or signals that data will automatically be included in the table display.  

In general, the GUI tries to keep possible extensions to libmapper like this in mind. Very little is assumed about the network itself. In turn, the only device metadata that \emph{must} exist is the name and number of inputs/outputs, which is used to either display the device as a source or destination. For signals, the GUI takes vector length into account when deciding whether two signals are compatible and can be connected. However, dis-including length in the signal metadata will not result in an error.
	
	% subsection display_libmapper_metadata (end)

	\subsection{Locating devices and signals} % (fold)
	\label{sub:locating_devices_and_signals}

In networks with dense arrays of devices or signals, it can be difficult to find particular objects. Three features from Maxmapper were adapted for use with the list view to aid the user with such tasks.

First, regular expression\footnote{TODO} supporting search-bars are not present at the top of each table. If the user types an expression of any kind into either of these fields, the GUI will filter elements displayed in the table beneath. Table rows can be filtered not just by the names of the signals/devices, but also by length, units, IP address or any other piece of information in the table row. To make the filter more responsive, the filtration code runs with every keypress, such that the table is dynamically filtered as the user inputs characters to the search field. 

A common encountered use-case for Maxmapper was a dense field of signals with only a handful of connections that needed to be constantly modified. Obviously scrolling through a list hundred of rows long only to select between the same connections repeatedly can be very tedious. To assist these users Maxmapper features a ``hide-unconnected'' button that was incorporated into the list view as well. The button sits in a previously unused piece of screen above the canvas containing the arrows (see figures \ref{fig:list_view_all_devices} and \ref{fig:list_view_single_link}). When clicked, the GUI hides all signals not currently connected to any others. The text on this button then changes to ``show-unconnected.''

\begin{figure}
	\centering
	\includegraphics[width=1\textwidth]{figures/hide_unconnected}
\caption{Functionality of hiding unconnected elements on a network with many devices and few links.}
\label{fig:hide_unconnected}
\end{figure}

Finally, tables will sort when a user clicks on a column header. Signals and devices are initially placed into the table in whichever order they appear in the model. Upon a click to any column header, the table sorts the information ``descending'' (first numerically, then alphabetically) by that column. A second click on the same header will re-sort the information in an ``ascending'' fashion. Table rows can be sorted by any metadata appearing in the table.

	% subsection locating_devices_and_signals (end)

	\subsection{Visual feedback} % (fold)
	\label{sub:visual_feedback}

User feedback was a very important part of the design process (see section \ref{sec:user_feedback}). One comment re-iterated by nearly all users of this GUI and prior GUIs was that it became extremely frustrating when the display became out of sync with the network, or when it seemed like the GUI \emph{might} be out of sync. To ameliorate these difficulties, the GUI incorporates a few Maxmapper features entirely for visual feedback.
		
		% # of signals/etc.
At the very bottom of the display is a bar showing the number of features on the network vs the number currently visible. For example, if there are 36 source devices on the network, but the user has filtered out all but two by either search filters or the ``hide-unconnected'' button, then the field underneath the source table will read ``2 of 36 devices'' (as in figure \ref{fig:hide_unconnected}). This data is also show for destination devices, links, connections and signals. This is done in order to help the user diagnose technical problems. If a desired signal is not appearing perhaps the device has become unresponsive or the user has encountered a bug in the GUI. If the user has simply filtered out the signal somehow, it is much more straightforward to see this immediately than to begin searching for possible errors.\footnote{libmapper, the GUI and most DMIs used with both are still in a stage of development where bugs are an inevitable part of the user experience. We like to call them ``features.''}

		%top toolbar, muting
The top toolbar automatically reflects metadata for selected connections. Expressions, connection modes and ranges can be observed simply by clicking on the arrow representing a connection. The toolbar displays non editable fields (depending on connection mode) as slightly more transparent. Arrows are re-drawn with dashed lines for muted connections. Figure \ref{fig:list_view_single_link} displays two muted connections. 

		% row striping
Though not feedback on the network itself, users have found large tables to be more easily navigable when row have ``zebra'' striping. The display re-calculates the alternate row striping any time a user filters the view. Rows highlight themselves when selected. Any number of rows on either table can be selected simultaneously. Row highlighting works in combination with row striping. 

\begin{figure}[!h]
	\centering
	\includegraphics[width=1\textwidth]{figures/row_striping}
	\caption{Multiple selection and row striping in the list view.}
	\label{fig:row_striping}
\end{figure}

By incorporating popular visual feedback elements from Maxmapper, we were able to make the display more robust and useful. Though difficulties with interaction can still occur (missing devices, unresponsive connections, etc.), good visual feedback should allow users to more quickly diagnose and solve these problems.

	% subsection visual_feedback (end)

	\subsection{Improvements to User Interaction} % (fold)
	\label{sub:improvements_to_user_interaction}

Easily the greatest user complaint about Webmapper was the nature of interaction. In order to form a connection, a user must click on a source device, then click on a destination device, then finally click on a ``connect'' button. Even for simple mappings this became extremely cumbersome. In order to make our GUI useful, we clearly needed to improve on the speed of interaction. Fortunately UI features in Maxmapper can solve this problem.
	
		\subsubsection{Draggable links and connections}

The drag to connect gesture is common among similar interfaces (\citeNP{patchage}, \shortciteNP{integra}), along with Maxmapper itself. Though more advanced to program than the improvements listed above, it was seen as necessary to get libmapper users to switch to our GUI.

\begin{figure}[h]
	\centering
	\includegraphics[width=1\textwidth]{figures/drawing}
	\caption{Draggable links and connections.}
	\label{fig:drawing}
\end{figure}

On every table row the user can click and drag onto the central canvas. Upon doing so, a slightly-thicker B\'ezier curve follows the mouse pointer about the canvas. Incompatible signals (ones with different length than the starting signal) become transparent. Once the mouse pointer comes within 50 pixels of the other table the drawn arrow snaps to the nearest row (if compatible), highlighting that device or signal. The user then can mouse up and down the rows of the target table and the drawn arrow will continue snapping to the nearest available row. Once the user lifts up on the mouse button, the GUI sends a message to connect the appropriate signals (or link the appropriate devices) to libmapper.

Of course, the GUI does not draw the final linking/connecting arrow until a confirmation message is received from the monitor, by way of libmapper itself. Figure \ref{fig:drawing} demonstrates a dragged connection starting from a source signal and ending on a destination signal, though the same gesture is possible beginning with destination elements.

	%also possible to drag right to left

		\subsubsection{Keyboard shortcuts}

To further accelerate GUI operations, some keyboard shortcuts were added:

\begin{table}
	\centering
	\Tcaption{Shortcut keys in the list view}
	\label{tab:list_view_shortcut_keys}
		\begin{tabular}{l  l  l}
		\hline\hline
		key combination&action&from Maxmapper?\\
		\hline
		c 					& Connect/link selected rows & no\\
		delete 				& Disconnect/unlink all selected & yes\\
		command + a 		& Select all visible connections/links & yes\\
		alt + tab 			& Change tab to the right & no\\
		alt + shift + tab 	& Change tab to the left & no\\ 
		m 					& Mute all selected connections/links & yes\\
		\end{tabular}
\end{table}

For PC users, the ``select all'' key command is ``control + a.'' Tab changing is meant to further mimic functionality of web browsers. 

	% subsection improvements_to_user_interaction (end)

% section integration_of_interface_features (end)

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Extension of Control and Visual Elements} % (fold)
\label{sec:extension_of_control_and_visual_elements}

With the new web based framework up and running, it is fairly easy to extend interface features beyond that of Maxmapper. Requested features that would have been very difficult to implement in Max/MSP were added to the GUI. Also, two new view modes were created, taking advantage of the modular, MVC-style code base.

	\subsection{Multiple selection} % (fold)
	\label{sub:multiple_selection}

Unlike in Maxmapper, in our GUI it is possible to select table rows with a mouse click. Any combination of rows can be selected on either table. This allows for multiple signals or devices to be connected/linked simultaneously upon pressing the `c' key. This particular command connects the superset of all selected elements. 

\begin{figure}
	\centering
	\begin{subfigure}[]{0.49\textwidth}
		\centering
		\includegraphics[width=\textwidth]{figures/multi-select_before_connect}
		\caption{Multiple rows selected}
		\label{fig:multiple_connect_before}
	\end{subfigure}
	\begin{subfigure}[]{0.49\textwidth}
		\centering
		\includegraphics[width=\textwidth]{figures/multi-select_after_connect}
		\caption{After pressing the `c' key}
		\label{fig:multiple_connect_after}
	\end{subfigure}
	\caption{Simultaneous connection of multiple signals}\label{fig:multiple_connect}
\end{figure}

Users can also depress the ``shift'' key to select all rows between the click on row and the previously selected row. This is similar to functionality in other list interfaces like the Windows and Macintosh file browsers. Clicking anywhere on the container except for the tables deselects all currently selected rows.
	
	% subsection multiple_selection (end)

	\subsection{Accommodating varying window sizes} % (fold)
	\label{sec:accomodating_sizes}

One notable shortcoming of the Maxmapper GUI is inability to resize the application window. This obviously created problems for users with small screens, or those who would want to run Maxmapper side-by-side with other applications. The new GUI can be resized in the same fashion as any other application, supporting windows as small as 100 x 124 pixels (about 3cm x 3cm).\footnote{All physical screen sizes quoted in this section are for a 96 pixel-per-inch hi-res display. Lower resolution displays will result in larger windows.}

Upon resizing, the size and shape of various on-screen elements change dynamically to fit the new window size. The two device/signal tables always occupy two-fifths of the container area, with the central canvas filling the remaining fifth. The container itself fills the entire window not occupied by the top bar. It will expand to fill any size, but has a programmed minimum height of 150 pixels (about 4cm) and minimum width of 700 pixels (about 18cm). Upon hitting minimum dimensions, the GUI adds scroll bars to allow the user to view the entire display. Elements within the top menu fold onto multiple lines to accommodate narrower windows.

\begin{figure}
	\centering
	\begin{subfigure}[]{\textwidth}
		\centering
		\includegraphics[width=\textwidth]{figures/before_resize_1280x760}
		\caption{List view at 1280 x 760 pixels}
		\label{fig:before_resize}
	\end{subfigure}
	\begin{subfigure}[]{0.5\textwidth}
		\centering
		\includegraphics[width=\textwidth]{figures/after_resize_650x450}
		\caption{Same view resized to 650 x 450 pixels}
		\label{fig:after_resize}
	\end{subfigure}
	\caption{Resizing the list view window. Rows condense, scroll bars appear and the top menu collapses in the smaller version.}\label{fig:resizing}
\end{figure}

Maxmapper table rows have constant height. Unless many devices or signals are present large parts of the display are often empty. The list view calculates table elements to fill the available space, as can be seen in most of the figures of this chapter. Minimum row heights are set to 17 pixels. Once there is not enough space to accommodate all necessary rows, the GUI adds a scroll bar to the appropriate table. 

	% subsection accomodating_sizes (end)

	\subsection{Visual Redesign} % (fold)
	\label{sec:visual_redesign}

Keeping in line with visual guidelines summarized in section \ref{sec:data_viz}, we overhauled the look of the Webmapper interface to reduce visual noise, make better use of color and generally improve its aesthetic appeal. 

\begin{figure}[h]
\centering
	\includegraphics[width=\textwidth]{figures/before_redesign}
\caption{The list view before visual re-design}
\label{fig:before_redesign}
\end{figure}

First, much of the display area was wasted for simple networks, leading to the dynamic row sizing described above. The display was plagued by $1 + 1 = 3$ noise, causing negative space like the central canvas to attract the eye and making the display seem much more complex than necessary. All black borders were removed and font weight was lightened for all text, drastically reducing visual noise. Arrows now display with one-half of the stroke weight. This too reduces visual noise and also differentiates arrows during the dragging gesture in dense fields of connections.

The pink background, though whimsical and popular at IDMIL, was deemed to bright to be used effectively over such a large area. It also distracted from the red used to highlight selected connections and links. A neutral white was selected for the background, both to blend with input areas and to cause more contrast with row striping and highlights. Aside from the red for selected arrows, all colors are now a variation of an unobtrusive gray-blue. This contributes to the visual uniformity of the display, but also allows us to make visual distinctions between odd rows, even rows, selected rows, table headers and table footers without using borders.

Finally, a logo was added to the upper right hand corner of the display. The logo is a simplified version of the overall libmapper logo\footnote{Can be seen at \url{www.libmapper.org}} with a white background. The red highlight color is maintained to match highlighted links and connections.

	% subsection visual_redesign (end)

	\subsection{Alternate views} % (fold)
	\label{sec:alternate_views}

Jon Wilansky, a fellow master's student at IDMIL, created two new views for the GUI. These took advantage of the new MVC architecture for the program. With these views in place it finally became possible to test our foundational hypothesis that a variety of displays would aid in mapping tasks.

		\subsubsection{The grid view}

\begin{figure}[ht]
\centering
	\includegraphics[width=\textwidth]{figures/grid_w_cursor}
\caption{The grid view}
\label{fig:grid}
\end{figure}

First programmed and implemented was the ``grid'' view. The network is represented with two $m$-by-$n$ grids. The leftmost grid lists source devices horizontally and destination devices vertically. Links are formed by clicking on the square at the intersection between the desired source and destination devices. The other grid represents signals and connections. Signals must be explicitly added to this grid from the device grid by selecting the intersection and clicking add or pressing the `a' key. 

Both grids are fully filterable using text input fields below, and borrowing code from the list view. Grids are also zoomable using the endpoints of the scroll bars. Either the devices or signals grid can be hidden, allowing the user to focus on just a single grid. Because this view is more customizable than list, the designer added an option to save view settings, causing the view to remember which devices have been added to the signal grid.

The grid view provides visual feedback by highlighting the associated row and column when the user places the cursor over a grid intersection. Text of the relevant devices/signals is also highlighted in this situation. Colors are designed to match the gray-blue style in the list view mode, hopefully keeping the feel of a unified interface. Red is also used as a highlighted color for selected grid squares.

The top bar looks and functions in the exact same fashion for the grid view as in the list view. MVC architecture allows us to create modular view-control elements like this to be used with a variety of other view-controller pairs.

	\subsubsection{The hive view}

\begin{figure}[ht]
\centering
	\includegraphics[width=\textwidth]{figures/hive}
\caption{The hive view}
\label{fig:hive}
\end{figure}
	
The hive view attempts to address the problem of to visualize entire networks simultaneously. The visualization borrows many techniques from Vizmapper (see section \ref{sub:vizmapper}). Solid black lines emanating from the center of the view signify network devices. Small circles representing child signals are distributed throughout each line. Thin blue curves flow between these circles, signifying connections. 

On the left side of the view, a menu displays expandable and collapsible list of all network devices. Expanding entries in this list displays child signals. Connection lines highlight to red when clicked, and the bottom bar (colored our standard blue) displays the connected signals. Mousing over device lines highlights all connections to that device. The same is true for mousing over individual signals or any item in the list on the left.

A text filter in the bottom right can narrow down the number of blue connection lines, though the black device lines persist. Connection lines can also be hidden by toggling check-boxes to the left of items in the device list on the left.

As of the writing of this thesis the hive view is not as fully interactive as the other two. It is not possible form connections or links by any means, though a dragging-type interaction like the list view would be most desirable. It is possible to modify selected connections using the top toolbar as in the other two views.

	% subsection alternate_views (end)

% section extension_of_control_and_visual_elements (end)

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Other GUI features} % (fold)
\label{sec:other_gui_features}

	\subsection{Saving \& Loading} % (fold)
	\label{sec:saving_and_loading}

Saving and loading presents an interesting problem for libmapper networks.  Upon clicking the ``save'' button, connection information is serialized into a JSON file which the user is asked to name. Only visible connections, ones that are present in the selected tab in list view, are recorded to the save file. Saving is not yet fully supported for the grid or hive views.

A ``na\"{i}ve'' interpretation of loading mappings is implemented here. Though device information is encoded into the save file, it is not considered in the loading process. Mappings are loaded for all applicable signals. For example, in the following situation:

\begin{itemize}
	\item Devices \url{tstick.1}, \url{tstick.2} and \url{granul8.1} exist on the network
	\item Both \url{tstick.1} and \url{tstick.2} have child signals named \url{raw/accelerometer/1/x} (they both should, as they are both t-sticks)
	\item A mapping is loaded that contains a connection \url{tstick.1/raw/accelerometer/1/x} $\rightarrow$ \url{granul8.1/filter/envelope/frequency/low}
\end{itemize}

The connection will be loaded for \emph{both} t-sticks, creating two total connections to \url{granul8.1}'s low filter envelope. If two instances of the granul8 synthesizer exist, than the connection will be loaded four times, one for each iteration of t-stick $\rightarrow$ granul8.

This is done to maintain a modularity for mappings, such that similar devices and equivalent devices with different names can share mappings. This makes sense for libmapper networks, as they are ideally collaborative and the ordinal number appearing after device names is arbitrary. 
	
	% subsection saving_&_loading (end)

	\subsection{Creation of a standalone \& distribution} % (fold)
	\label{sec:creation_of_a_standalone_and_distribution}
	
Ideally, the new GUI will be quickly be adopted by many users. This would assist us in debugging and improving the interface. It would also hopefully bring a new set of users to libmapper itself, encouraging use of the API and its implementation into new DMIs. Unfortunately, to get libmapper and this GUI up and running from scratch requires installing some kind of package management software and compiling multiple dependencies. This is rather time consuming and well beyond what should be expected of a non-programmer. 

To aid in ease-of-use and adoption a ``standalone'' version of our GUI was compiled, and is presently available for free download at \url{www.libmapper.org/downloads} under the name Webmapper\footnote{We have yet to invent a suitable new name.}. The standalone includes libmapper code, and thus can be run on a machine that does not have libmapper explicitly installed. To the user it looks like any other Macintosh application: an icon to double-click.

The current version (0.2) is still very much in test phase, and includes a readme file describing likely bugs, and the non-ideal startup method.\footnote{Running the program and navigating to \url{localhost:50000} in the Google Chrome browser.} It presently supports Macintosh OSX only, though Linux and Microsoft Windows releases are planned.

	% subsection creation_of_a_standalone_&_distribution (end)

% section other_gui_features (end)




