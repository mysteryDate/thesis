%!TEX root = ../thesis.tex
\chapter{Design \& Implementation}

	Development of a graphical user interface for libmapper creates a unique challenge. Obviously such an interface is a practical tool, and should function as such, yet it also must work in concert with DMIs which are inherently designed for abstract and creative use. For the purposes of this project, the assumed solution to this innate paradox is to provide the user with multiple independent modes of control.  This assumption was made based on experiences with prior user interfaces for libmapper (vizmapper, max mapperGUI): for each interface users reported excellent functionality for certain use cases, and poor functionality for others. Libmapper itself is an extremely flexible API that makes few assumptions as to the network of devices and signals, nor how they are being mapped. It is fitting that a GUI for libmapper would be equally as flexible. In lieu of a single perfect solution for network visualization an interactivity, providing users with various independent solutions provided a good compromise.
	
\section{Design Background}

\begin{figure}[ht]
\centering
	\scalebox{0.42}{\hbox{\includegraphics{figures/webmapper}}}
\caption{The webmapper interface}
\label{fig:webmapper}
\end{figure}

Work on this project began with a moderately featured, little used GUI for libmapper known as ``webmapper.'' Webmapper was created at IDMIL as an attempt to replace the Max/MSP GUI as the result of limitations described in section \ref{sec:similar_interfaces}, the principle among which being the cross-platform incompatibility of Max/MSP. It was thought that a browser-based approach would greatly simplify the process of creating cross-compatibility with all major operating systems and even mobile devices. 

Webmapper utilizes the Python bindings for libmapper by registering an administrative monitor to communicate with a libmapper network. The monitor can create and modify connections or links, as well as query the network as to what devices, signals, links and connections are present. The webmapper code creates a simple HTTP server and attempts to open Google Chrome\footnote{Chrome Browser. [Online]. Available: \url{https://www.google.com/intl/en/chrome/browser/}. Accessed July 17, 2013} on the host computer. If Google Chrome is not present, the user must navigate directly to the server using the web address \url{localhost:50000}. The monitor communicates with the libmapper network and the local server, the browser is able to see messages the monitor ``posts'' to the server (such as `new device') and respond to them appropriately. The browser in turn can send messages to the server (like `connect') that will propagate up to libmapper itself, eventually resulting in a message cascading back down to the browser reflecting the change to the network (such as `new connection'). 

The interface itself is written for a web browser using the scripting language JavaScript\footnote{JavaScript | MDN. [Online]. Available: \url{https://developer.mozilla.org/en-US/docs/Web/JavaScript}. Accessed July 17, 2013} to control web-standard HyperText Markup Language (HTML) elements and Cascading Style Sheets (CSS). The JavaScript code stores four main data structures: devices, links, connections and signals. The code never directly modifies any of this data, and instead waits for messages relayed from libmapper. For example, if a user creates a new link, webmapper does not add a link to the links array but simply sends a message to the network. If it receives a `new link' message back, only then does it add the new link to the array. This is done to ensure that the data structures within webmapper always reflect what is actually present on the network in the case that messages are dropped, an error occurs, etc.

Figure \ref{fig:webmapper} shows the look of the interface before the work of this project began. Users are able to perform all libmapper functions: connecting, linking and modifying connections, but only the simplest of feature sets is included. For example, in order to form a connection the user must click on a source signal, click on a destination signal and then click on a button labeled ``connect.'' Many useful features of the Max/MSP interface, such as column headers, table sorting, drawing connections and search filtering are not present.

\section{Development of a Flexible Interface}
	
Prior GUIs for libmapper have been successfully used for some time, but all have failed to become a standard for one reason: they cannot accommodate all possible use-cases of libmapper. List based views like the Max/MSP GUI and webmapper cannot show hierarchies while the cluster view implemented in vizmapper can be overly cumbersome for interaction with simple networks. Especially with so much work already completed on prior GUIs, it was more suitable to integrate different approaches into a single GUI than to begin work on some new, hopefully superior approach that would likely prove to be flawed like all that came before it. 

Interface integration was accomplished through an extremely simple approach: a drop-down menu was added to the upper left corner of the interface. Options on this menu represent different visualization modes available to the user. By selecting 
	%Needs to be adaptable, show any metadata

\subsection{List view}
\label{sec:list_view}

The first implemented, and thus far most functional view mode for the GUI is the ``list'' view. Based heavily on the Max/MSP GUI described in section \ref{sec:similar_interfaces}, 

\subsection{Grid view}
\subsection{Hive plot}
\subsection{Cluster view (vizmapper)}

\section{Control Features}
\subsection{Creating Connections/Links}
\subsection{Modifying Signals}

\section{The Model-View-Controller}
\label{sec:MVC}

	Because a modular design is desired, the Model-View-Controller (MVC) metaphor for structuring software applications as described in [KrasnerPope88] was used as a general framework for structuring the application. In fact, the whole scale swapping in and out of independent visual modes can be thought of as a quintessential implementation of MVC. 
	
\subsection{The Model}

	The model consists of an abstract copy of the network, residing on the local machine. Independent views can consult this data, but cannot directly modify it.

\subsection{Controller-View Pairs}

\section{Graphical Design}
	wiggly arrows
\subsection{Typography}

\begin{figure}[ht]
\centering
	\scalebox{0.4}{\includegraphics{figures/final_list}}
\caption{The list view after redesign}
\label{fig:final_list}
\end{figure}

\begin{figure}[ht]
\centering
	\scalebox{0.4}{\includegraphics{figures/grid}}
\caption{The grid view}
\label{fig:grid}
\end{figure}

\begin{figure}[ht]
\centering
	\scalebox{0.4}{\includegraphics{figures/hive}}
\caption{The hive view}
\label{fig:hive}
\end{figure}

	
\section{User Centric Design}
	use cases

\section{Robustness and Responsiveness}
	speed tests

\section{Creation of a Standalone}